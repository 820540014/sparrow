<!-- TOC depthFrom:1 depthTo:6 withLinks:1 updateOnSave:1 orderedList:0 -->

- [第0章-一些可能令人迷惑的问题](#第0章-一些可能令人迷惑的问题)
	- [成功的基石不是坚持，而是“不放弃”](#成功的基石不是坚持而是不放弃)
	- [你懂编程语言的“心”吗？](#你懂编程语言的心吗)
	- [编程语言的来历](#编程语言的来历)
	- [语言一定要更底层的语言来编写吗？](#语言一定要更底层的语言来编写吗)
	- [编译型程序和脚本程序的异同](#编译型程序和脚本程序的异同)
	- [END](#end)

<!-- /TOC -->
# 第0章-一些可能令人迷惑的问题

## 成功的基石不是坚持，而是“不放弃”

* 编译原理还是很难滴，说不难是对大家上进心的不尊重
* 选择技术的原因只是我没有辣么讨厌它，它是我从众多讨厌的事物中选择的最不讨厌的东西。这个思维很有趣
* 凡事靠坚持来做的事情必然建立在痛苦之上，痛苦使人产生放弃念头
* 不要给自己“可以放弃”的念头，不要让“可以放弃”成为一种选项，把选项去掉，剩下成功只是时间问题

## 你懂编程语言的“心”吗？

* 语言的“心”本质就是编译器，程序员多数了解如何使用编译器，如何满足编译器规则写出相应的代码。极少数了解编译器到底做了哪些工作
* 编程语言的本质就是 编译器将人类思想转换为“计算机行为”的语法规则。将高级语言转换为低级语言，将人可阅读的符号转换为机器可执行二进制序列，将需求转换为实现


## 编程语言的来历

* 世界上本没有编程语言，有的只是编译器
* 语言本身只是一系列语法规则。规则对应着行为，行为才是编程的意图
* 编译器就是规则到行为的解析。语言规则多样性，但是本质都是万变不离其宗

## 语言一定要更底层的语言来编写吗？

* 该问题等价于，编译器是否由其他编译器实现？对的可以的，但是如果追溯到一开始，C语言难道不是汇编写的么？然后再用C语言编译器造出更牛逼的C语言编译器，确实是这样的，典型的编译器新增特性就是在原来基础上增加，典型的Gcc源码编译，也是用Gcc编译新的Gcc
* **肯定是现有编程语言，然后制造配套的编译器**，编译器的制造是根据编程语言的规则来开发的，类似于按照图纸盖楼一样
* C语言有很多种编译器支持，每种编译器有不同特性，为此肯定会有兼容性问题，所以也肯定会诞生很多标准，这都是想都不用想肯定会涉及到的问题。
* **工具可以用来造工具，编译器可以用来造编译器**
* 编译器基本功能就是读写文件，读源码，写汇编，交给你汇编器搞成机器码。平常用的gcc一条龙服务你看不到中间文件的生成，但是如果编译的时候加一些选项你就看到了。
* 最初的编译器使用机器码写的，这个没意见吧？

![1534922397616.png](image/1534922397616.png)

## 编译型程序和脚本程序的异同

* 脚本本质是脚本代码交个脚本解释器在运行时实时分析这个脚本。
* 脚本解释器有两类
	- 一类是边解释边执行
	- 一类是解释完后执行


![1534921980309.png](image/1534921980309.png)

## END
